[
  {
    "objectID": "posts/purrr_for_data_validation/index.html",
    "href": "posts/purrr_for_data_validation/index.html",
    "title": "Purrr for Data Validation",
    "section": "",
    "text": "This post explains an insight I had when thinking about a data validation problem, and I hope this example problem will get you thinking more creatively about the possibilities of nested tibbles. (If you’re not familiar with the nested data workflow, read this this concise article first.)\nSo, you’re at least somewhat familiar with the nested data workflow. That is, grouping your data and nesting each group’s data into cells in a column called “data”. You wind up with a Tidy, summarized tibble with one row per group so you can work with the nested data as a single unit.\nBut did you ever think of nesting source code into a cell? If you’re at all curious about how or why this might be a good idea, keep reading.\nMy specific problem required running a bunch of data validation functions on a dataset while neatly keeping track of the functions and their results. This reminded me of the nested data workflow, but instead of iterating over groups of data, I wanted to iterate over a group of validation functions. My insight was to nest each function’s source code into the tibble, execute each one on the data, and nest the results into a column.\nFor even more background on the nested data paradigm, read this chapter of R4DS."
  },
  {
    "objectID": "posts/purrr_for_data_validation/index.html#example-data",
    "href": "posts/purrr_for_data_validation/index.html#example-data",
    "title": "Purrr for Data Validation",
    "section": "Example Data",
    "text": "Example Data\nI’ll use iris as the example dataset. It’s got four decimal fields and one factor field per observation.\n\n\n# A tibble: 150 × 6\n   id    Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n   &lt;chr&gt;        &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  \n 1 1              5.1         3.5          1.4         0.2 setosa \n 2 2              4.9         3            1.4         0.2 setosa \n 3 3              4.7         3.2          1.3         0.2 setosa \n 4 4              4.6         3.1          1.5         0.2 setosa \n 5 5              5           3.6          1.4         0.2 setosa \n 6 6              5.4         3.9          1.7         0.4 setosa \n 7 7              4.6         3.4          1.4         0.3 setosa \n 8 8              5           3.4          1.5         0.2 setosa \n 9 9              4.4         2.9          1.4         0.2 setosa \n10 10             4.9         3.1          1.5         0.1 setosa \n# … with 140 more rows\n# ℹ Use `print(n = ...)` to see more rows"
  },
  {
    "objectID": "posts/purrr_for_data_validation/index.html#the-field-test-catalog",
    "href": "posts/purrr_for_data_validation/index.html#the-field-test-catalog",
    "title": "Purrr for Data Validation",
    "section": "The Field-Test Catalog",
    "text": "The Field-Test Catalog\nAs I thought about the problem, it became clear that I would want to define a set of tests for each field and keep track of the field-test catalog in a list or a table structure.\nThe catalog of field-tests might look something like this:\n\n\n\nField Name\nTest Name\n\n\n\n\nSepal.Length\nis_missing\n\n\nSepal.Length\nis_not_between_3_and_7\n\n\nSepal.Length\nis_less_than_sepal_width\n\n\n…\n…\n\n\nSepal.Width\nis_missing\n\n\nSepal.Width\n…\n\n\n…\n…\n\n\nPetal.Length\nis_missing\n\n\nPetal.Length\nis_not_between_4_and_7_when_species_is_virginica\n\n\n…"
  },
  {
    "objectID": "posts/purrr_for_data_validation/index.html#desired-output-form",
    "href": "posts/purrr_for_data_validation/index.html#desired-output-form",
    "title": "Purrr for Data Validation",
    "section": "Desired Output Form",
    "text": "Desired Output Form\nI wanted to generate a set of results for each field-test that I could tie back to individual observations in the data. Results for one particular field’s test would look like this:\n\n\n\nId\nResult\n\n\n\n\n1\nFALSE\n\n\n2\nFALSE\n\n\n…\n…\n\n\n149\nTRUE\n\n\n150\nFALSE\n\n\n\nThis is of course not very useful without knowing its corresponding field and test, so an expanded set of results might look like this:\n\n\n\n\n\n\n\n\n\nField\nTest\nId\nResult\n\n\n\n\nSepal.Length\nis_missing\n1\nTRUE\n\n\nSepal.Length\nis_missing\n2\nFALSE\n\n\nSepal.Length\nis_missing\n…\n…\n\n\nSepal.Length\nis_missing\n138\nTRUE\n\n\n…\n\n\n\n\n\nPetal.Width\nis_not_between_4_and_7_when_species_is_virginica\n32\nNA\n\n\n…\n\n\n\n\n\nPetal.Width\nis_not_between_4_and_7_when_species_is_virginica\n138\nFALSE\n\n\n…\n\n\n\n\n\nSpecies\nis_not_within_known_set\n1\nTRUE\n\n\n…\n…\n\n\n\n\n\nThe objects I would need to keep track of included:\n\nthe field-test catalog\neach field-test’s source code, parameters, and description\neach field-test’s results\nand the iris_tbl dataset itself\n\nThis smelled like the nested data workflow, but inverted. Rather than mapping one function to a group of datasets, I would feed one dataset to a group of functions."
  },
  {
    "objectID": "posts/fantasy_football_luck/index.html",
    "href": "posts/fantasy_football_luck/index.html",
    "title": "Coming Soon: Fantasy Football Schedule Luck",
    "section": "",
    "text": "Coming soon.\nI need to dust off the old code (base R!), so i’ll be a minute, but the gist is:\n\nIn 2018 I scraped my ESPN fantasy league’s 15-season history, saving the weekly league members’ points in a csv.\nThen I re-simulated every season a million times, taking each owner’s weekly score as given, but randomizing the season’s head to head schedules.\nWith the simulation results we can explore owners’ win-loss distributions, their expected win rates, see who got lucky or unlucky in a given year, and if there’s been any persistent luck pattern over the years.\nI find that schedule plays a huge role in determining playoff berths and using an all-play schedule format (where you play every other team each week) would mitigate this."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Aaron’s Data Science and Coding Blog",
    "section": "",
    "text": "Welcome!\nI want to get some of my coding thoughts out into the world, so this is a sort of code portfolio in blog form.\nI really enjoy the Posit/RStudio workflows, as well as coding in R, so I used Quarto to build this.\nI’ll be posting more as I get the chance, but check out my first post:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPurrr for Data Validation\n\n\nOr: Nesting Functions Into a Tibble\n\n\nTidyverse R enthusiasts know about nesting grouped data into a column and iterating using purrr::map(), but did you know you could nest function source code? This post uses a data validation example to explain how I used this nest-and-iterate pattern over a set of validation tests while keeping the tests, their code, and their results in one Tidy tibble.\n\n\n\n\n\nFeb 11, 2024\n\n\nAaron Politsky\n\n\n\n\n\n\n\n\n\n\n\n\nComing Soon: Fantasy Football Schedule Luck\n\n\nMeasuring the Impact of Head-to-Head Schedules on Playoff Berths\n\n\n\ndata science\n\n\n\nYour fantasy team put up a ton of points over the season, yet you missed the playoffs because your opponents always had their best weeks against you. How would your season have gone if you had a different schedule? I re-simulate 15 years of league history to quantify how un/lucky my league’s participants have been and to measure how much making the playoffs depends on schedule. (Spolier: a LOT!)\n\n\n\n\n\nFeb 11, 2024\n\n\nAaron Politsky\n\n\n\n\n\n\nNo matching items"
  }
]