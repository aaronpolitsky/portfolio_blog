{
  "hash": "55146c0b2445c91eabf5dc1a5b5df093",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Purrr for Data Validation\"\nsubtitle: \"Or: Nesting Functions Into a Tibble\"\nauthor: \"Aaron Politsky\"\ndate: \"2/11/2024\"\ndescription: \"Tidyverse R enthusiasts know about nesting grouped data into a column and iterating using purrr::map(), but did you know you could nest function source code? This post uses a data validation example to explain how I used this nest-and-iterate pattern over a set of validation tests while keeping the tests, their code, and their results in one Tidy tibble.\"\n---\n\n\n# Intro\n\nThis post explains an insight I had when thinking about a data validation problem, and I hope this example problem will get you thinking more creatively about the possibilities of nested tibbles. (If you're not familiar with the nested data workflow, read this [this concise article](https://tidyr.tidyverse.org/articles/nest.html) first.)\n\nSo, you're at least somewhat familiar with the nested data workflow. That is, grouping your data and nesting each group's data into cells in a column called \"data\". You wind up with a Tidy, summarized tibble with one row per group so you can work with the nested data as a single unit.\n\nBut did you ever think of nesting *source code* into a cell? If you're at all curious about how or why this might be a good idea, keep reading.\n\nMy specific problem required running a bunch of data validation functions on a dataset while neatly keeping track of the functions and their results. This reminded me of the nested data workflow, but instead of iterating over groups of *data*, I wanted to iterate over a group of validation functions. My insight was to nest each function's *source code* into the tibble, execute each one on the data, and nest the results into a column.\n\nFor even more background on the nested data paradigm, read [this chapter of R4DS](https://r4ds.had.co.nz/many-models.html).\n\n# The Data Validation Problem\n\nI wanted to validate new data as it arrived to get a sense of its reliability, so I needed to test certain fields to determine if their values made sense and were analytically useful. I had to run a set of tests on each value in the dataset in order to:\n\n-   determine what subset of the data was OK to use right away,\n\n-   judge whether the dataset as a whole was ok to use,\n\n-   and decide whether I would need to contact the data provider to address any quality issues.\n\nMany tests were sanity checks, whether a datapoint fell between a lower and upper bound, among others. Others could be more complex. Each field required its own set of validation tests, sometimes fairly unique to that field.\n\n## Example Data\n\nI'll use iris as the example dataset. It's got four decimal fields and one factor field per observation.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 150 × 6\n   id    Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n   <chr>        <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n 1 1              5.1         3.5          1.4         0.2 setosa \n 2 2              4.9         3            1.4         0.2 setosa \n 3 3              4.7         3.2          1.3         0.2 setosa \n 4 4              4.6         3.1          1.5         0.2 setosa \n 5 5              5           3.6          1.4         0.2 setosa \n 6 6              5.4         3.9          1.7         0.4 setosa \n 7 7              4.6         3.4          1.4         0.3 setosa \n 8 8              5           3.4          1.5         0.2 setosa \n 9 9              4.4         2.9          1.4         0.2 setosa \n10 10             4.9         3.1          1.5         0.1 setosa \n# … with 140 more rows\n# ℹ Use `print(n = ...)` to see more rows\n```\n\n\n:::\n:::\n\n\n## The Field-Test Catalog\n\nAs I thought about the problem, it became clear that I would want to define a set of tests for each field and keep track of the field-test catalog in a list or a table structure.\n\nThe catalog of field-tests might look something like this:\n\n| Field Name   | Test Name                                        |\n|--------------|--------------------------------------------------|\n| Sepal.Length | is_missing                                       |\n| Sepal.Length | is_not_between_3_and_7                           |\n| Sepal.Length | is_less_than_sepal_width                         |\n| ...          | ...                                              |\n| Sepal.Width  | is_missing                                       |\n| Sepal.Width  | ...                                              |\n| ...          | ...                                              |\n| Petal.Length | is_missing                                       |\n| Petal.Length | is_not_between_4_and_7_when_species_is_virginica |\n| ...          |                                                  |\n\n## Desired Output Form\n\nI wanted to generate a set of results for each field-test that I could tie back to individual observations in the data. Results for one particular field's test would look like this:\n\n| Id  | Result |\n|-----|--------|\n| 1   | FALSE  |\n| 2   | FALSE  |\n| ... | ...    |\n| 149 | TRUE   |\n| 150 | FALSE  |\n\nThis is of course not very useful without knowing its corresponding field and test, so an expanded set of results might look like this:\n\n| Field        | Test                                             | Id  | Result |\n|-----------------|---------------------|-----------------|-----------------|\n| Sepal.Length | is_missing                                       | 1   | TRUE   |\n| Sepal.Length | is_missing                                       | 2   | FALSE  |\n| Sepal.Length | is_missing                                       | ... | ...    |\n| Sepal.Length | is_missing                                       | 138 | TRUE   |\n| ...          |                                                  |     |        |\n| Petal.Width  | is_not_between_4_and_7_when_species_is_virginica | 32  | NA     |\n| ...          |                                                  |     |        |\n| Petal.Width  | is_not_between_4_and_7_when_species_is_virginica | 138 | FALSE  |\n| ...          |                                                  |     |        |\n| Species      | is_not_within_known_set                          | 1   | TRUE   |\n| ...          | ...                                              |     |        |\n\nThe objects I would need to keep track of included:\n\n1.  the field-test catalog\n\n2.  each field-test's source code, parameters, and description\n\n3.  each field-test's results\n\n4.  and the iris_tbl dataset itself\n\nThis smelled like the nested data workflow, but inverted. Rather than mapping one function to a group of datasets, I would feed one dataset to a group of functions.\n\n# Nesting the Function Code into a Tibble\n\nI made a hierarchical list for the field test functions, and then I converted it into a tibble like so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfield_test_functions_list <- list(\n  \"Sepal.Length\" = list(\n    \"is_missing\" = function(data) {\n      data %>% \n        mutate(result = is.na(Sepal.Length)) %>% \n        select(id, result)\n    }\n  ),\n  \"Sepal.Width\" = list(\n    \"is_missing\" = function(data) {\n      data %>% \n        mutate(result = is.na(Sepal.Width)) %>% \n        select(id, result)\n    }\n  ),\n  \"Petal.Length\" = list(\n    \"is_missing\" = function(data) {\n      data %>% \n        mutate(result = is.na(Petal.Width)) %>% \n        select(id, result)\n    },\n    \"is_not_between_4_and_7_when_species_is_virginica\" = function(data) {\n      data %>% \n        mutate(result = if_else(Species == \"virginica\",  \n                                !between(Petal.Length, 4, 7),\n                                NA)) %>%\n        select(id, result)\n    }\n  ),\n  \"Species\" = list(\n    \"is_not_within_known_set\" = function(data) {\n      data %>% \n        mutate(result = \n                 !(Species %in% c(\"setosa\", \"versicolor\", \"virginica\"))) %>% \n        select(id, result)\n    }\n  )\n)\n```\n:::\n\n\nNow let's convert that to a tibble, in steps.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(field_test_functions_list, enframe, name = \"test\", value = \"fun\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$Sepal.Length\n# A tibble: 1 × 2\n  test       fun   \n  <chr>      <list>\n1 is_missing <fn>  \n\n$Sepal.Width\n# A tibble: 1 × 2\n  test       fun   \n  <chr>      <list>\n1 is_missing <fn>  \n\n$Petal.Length\n# A tibble: 2 × 2\n  test                                             fun   \n  <chr>                                            <list>\n1 is_missing                                       <fn>  \n2 is_not_between_4_and_7_when_species_is_virginica <fn>  \n\n$Species\n# A tibble: 1 × 2\n  test                    fun   \n  <chr>                   <list>\n1 is_not_within_known_set <fn>  \n```\n\n\n:::\n:::\n\n\nNow let's make that into a tibble using enframe\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(field_test_functions_list, enframe, name = \"test\", value = \"fun\") %>% \n  enframe(name = \"field\", value = \"test_tibble\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  field        test_tibble     \n  <chr>        <list>          \n1 Sepal.Length <tibble [1 × 2]>\n2 Sepal.Width  <tibble [1 × 2]>\n3 Petal.Length <tibble [2 × 2]>\n4 Species      <tibble [1 × 2]>\n```\n\n\n:::\n:::\n\n\nAnd one more step: unnest the test_tibbles\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfield_test_tibble <- \n  lapply(field_test_functions_list, enframe, name = \"test\", value = \"fun\") %>% \n  enframe(name = \"field\", value = \"test_tibble\") %>%  \n  unnest(test_tibble)\n\nfield_test_tibble\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  field        test                                             fun   \n  <chr>        <chr>                                            <list>\n1 Sepal.Length is_missing                                       <fn>  \n2 Sepal.Width  is_missing                                       <fn>  \n3 Petal.Length is_missing                                       <fn>  \n4 Petal.Length is_not_between_4_and_7_when_species_is_virginica <fn>  \n5 Species      is_not_within_known_set                          <fn>  \n```\n\n\n:::\n:::\n\n\nNow we have our Tidy field-tests tibble, and we're ready to iterate using purrr::map.\n\n# The Real Trick: How to Invoke purrr::map()\n\nWe are iterating over test functions we've named `fun`, and we want to *execute* each of them. This is the really meta part: we want to `map()` the function `exec()` onto each `fun`.\n\nIn `purrr::map` syntax, where we normally would map a function .f to data .x like this: `map(.x = data, .f = fun)`\n\nBut instead we do this: `map(.x = fun, .f = exec)`\n\nAnd since each `fun` expects the argument `data`, we pass it as a third argument: `map(.x = fun, .f = exec, data = iris_tbl)`\n\nThis will produce our result tibble for each field test, so we can do that all within mutate like so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfield_tests_with_results <- \n  field_test_tibble %>% \n  mutate(results = map(.x = fun, .f = exec, data = iris_tbl))\n\nfield_tests_with_results %>% \n  select(field, test, results)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  field        test                                             results \n  <chr>        <chr>                                            <list>  \n1 Sepal.Length is_missing                                       <tibble>\n2 Sepal.Width  is_missing                                       <tibble>\n3 Petal.Length is_missing                                       <tibble>\n4 Petal.Length is_not_between_4_and_7_when_species_is_virginica <tibble>\n5 Species      is_not_within_known_set                          <tibble>\n```\n\n\n:::\n:::\n\n\nAnd of course, we can then unnest our results into our desired tabular output:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfield_tests_with_results %>% \n  select(field, test, results) %>% \n  unnest(results)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 750 × 4\n   field        test       id    result\n   <chr>        <chr>      <chr> <lgl> \n 1 Sepal.Length is_missing 1     FALSE \n 2 Sepal.Length is_missing 2     FALSE \n 3 Sepal.Length is_missing 3     FALSE \n 4 Sepal.Length is_missing 4     FALSE \n 5 Sepal.Length is_missing 5     FALSE \n 6 Sepal.Length is_missing 6     FALSE \n 7 Sepal.Length is_missing 7     FALSE \n 8 Sepal.Length is_missing 8     FALSE \n 9 Sepal.Length is_missing 9     FALSE \n10 Sepal.Length is_missing 10    FALSE \n# … with 740 more rows\n# ℹ Use `print(n = ...)` to see more rows\n```\n\n\n:::\n:::\n\n\nBut why do it this way? Couldn't I just do this using vectors and lists?\n\n# A Fine, but Less Tidy Method Using Lists\n\nOne way I might have done this before knowing about nested tibbles is to iterate over the field test list to create a separate, hierarchical results list.\n\nThis is...fine. But if you're used to working with Tidy tibbles and dplyr-like verbs you might find it unsatisfying.\n\nFurthermore, if you care about future-proofing it for other users (including your future self), it might bother you that the field test code will be in one object and its results in another. Mistakes happen!\n\nGiven the field_test_functions_list I created above, I would iterate over our fields using lapply, and within that, iterate over each of its tests using another lapply.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# iterate over field names, and test names within them, executing test functions on iris\nfield_test_results <- lapply(X = field_test_functions_list, \n                             # for each field fn, which is a list of tests...\n                             FUN = function(tests) {\n                               # execute each test, each of which are functions\n                               lapply(X = tests, \n                                      FUN = function(test) {\n                                        exec(test, data = iris_tbl)\n                                      })\n                             })\n\nfield_test_results \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$Sepal.Length\n$Sepal.Length$is_missing\n# A tibble: 150 × 2\n   id    result\n   <chr> <lgl> \n 1 1     FALSE \n 2 2     FALSE \n 3 3     FALSE \n 4 4     FALSE \n 5 5     FALSE \n 6 6     FALSE \n 7 7     FALSE \n 8 8     FALSE \n 9 9     FALSE \n10 10    FALSE \n# … with 140 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\n\n$Sepal.Width\n$Sepal.Width$is_missing\n# A tibble: 150 × 2\n   id    result\n   <chr> <lgl> \n 1 1     FALSE \n 2 2     FALSE \n 3 3     FALSE \n 4 4     FALSE \n 5 5     FALSE \n 6 6     FALSE \n 7 7     FALSE \n 8 8     FALSE \n 9 9     FALSE \n10 10    FALSE \n# … with 140 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\n\n$Petal.Length\n$Petal.Length$is_missing\n# A tibble: 150 × 2\n   id    result\n   <chr> <lgl> \n 1 1     FALSE \n 2 2     FALSE \n 3 3     FALSE \n 4 4     FALSE \n 5 5     FALSE \n 6 6     FALSE \n 7 7     FALSE \n 8 8     FALSE \n 9 9     FALSE \n10 10    FALSE \n# … with 140 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\n$Petal.Length$is_not_between_4_and_7_when_species_is_virginica\n# A tibble: 150 × 2\n   id    result\n   <chr> <lgl> \n 1 1     NA    \n 2 2     NA    \n 3 3     NA    \n 4 4     NA    \n 5 5     NA    \n 6 6     NA    \n 7 7     NA    \n 8 8     NA    \n 9 9     NA    \n10 10    NA    \n# … with 140 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\n\n$Species\n$Species$is_not_within_known_set\n# A tibble: 150 × 2\n   id    result\n   <chr> <lgl> \n 1 1     FALSE \n 2 2     FALSE \n 3 3     FALSE \n 4 4     FALSE \n 5 5     FALSE \n 6 6     FALSE \n 7 7     FALSE \n 8 8     FALSE \n 9 9     FALSE \n10 10    FALSE \n# … with 140 more rows\n# ℹ Use `print(n = ...)` to see more rows\n```\n\n\n:::\n:::\n\n\nNow if we want to get to tabular data, we might need to access it using field names and field tests\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(field_test_results, lapply, count, result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$Sepal.Length\n$Sepal.Length$is_missing\n# A tibble: 1 × 2\n  result     n\n  <lgl>  <int>\n1 FALSE    150\n\n\n$Sepal.Width\n$Sepal.Width$is_missing\n# A tibble: 1 × 2\n  result     n\n  <lgl>  <int>\n1 FALSE    150\n\n\n$Petal.Length\n$Petal.Length$is_missing\n# A tibble: 1 × 2\n  result     n\n  <lgl>  <int>\n1 FALSE    150\n\n$Petal.Length$is_not_between_4_and_7_when_species_is_virginica\n# A tibble: 2 × 2\n  result     n\n  <lgl>  <int>\n1 FALSE     50\n2 NA       100\n\n\n$Species\n$Species$is_not_within_known_set\n# A tibble: 1 × 2\n  result     n\n  <lgl>  <int>\n1 FALSE    150\n```\n\n\n:::\n:::\n\n\nIt's fine to store the results in a list. But the Tidyverse likes tabular data, and I was ultimately going to target an expanded tibble having field, test name, id, and result, and that lent itself to using a nested tibble.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}