{
  "hash": "8be3d390fa9a1d636f44d3cea0277683",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Purrr for Data Validation\"\nsubtitle: \"Or: Nesting Functions Into a Tibble\"\nauthor: \"Aaron Politsky\"\ndate: \"2/11/2024\"\ndescription: \"Tidyverse R enthusiasts know about nesting grouped data into a column and iterating using purrr::map(), but did you know you could nest function source code? This post uses a data validation example to explain how I used this nest-and-iterate pattern over a set of validation tests while keeping the tests, their code, and their results in one Tidy tibble.\"\ntoc: TRUE\ntoc-location: left\n---\n\n\n# Intro\n\nThis post explains an insight I had when thinking about a data validation problem, and I hope this example problem will get you thinking more creatively about the possibilities of nested tibbles. (If you're not familiar with the nested data workflow, read this [this concise article](https://tidyr.tidyverse.org/articles/nest.html) first, and for more depth, read [this chapter of R4DS](https://r4ds.had.co.nz/many-models.html).) I'll wait.\n\nOK, Great. Now you're at least somewhat familiar with the nested data workflow. That is, grouping your data and nesting each group's data into cells in a column called \"data\". You wind up with a Tidy, summarized tibble with one row per group so you can work with the nested data as a if it were a single value in a cell.\n\nBut did you ever think of nesting *source code* into a cell? If you're at all curious about how or why this might be a good idea, keep reading.\n\nMy specific problem required running a bunch of data validation tests on a dataset, and I wanted to neatly keep track of the tests, their code, and their results. This reminded me of the nested data workflow, but instead of iterating over groups of *data*, I wanted to iterate over a group of validation functions. My insight was to nest each test's *source code* into the tibble, execute each test on the data, and nest its results into another column, leaving me with a single, Tidy tibble having the test names, their code, and their results.\n\nBut why do it this way? Couldn't you use base R using several separate lists and a vector of test names to access them? Sure, but I prefer having all this in one table. When everything is neatly tied together in rows it's less error prone. Plus it's Tidy, so it will be easy to work with later using the typical tidyverse methods.\n\nWhereas using separate lists, it's up to you to keep everything straight since the lists aren't aware of one another. Someone (such as *future me*) could come along and accidentally rename the elements of one of the lists without updating the others, and it would fail quietly.\n\nLet's motivate this solution with an example problem.\n\n# The Example Data Validation Problem\n\nIn my case, I periodically received new data, and I wanted to validate them after arrival to get a sense of reliability and readiness. I needed to test certain fields to determine if their values made sense and were analytically useful. I would run a set of tests on each value in the dataset in order to:\n\n-   determine what subset of the data was OK to use right away,\n\n-   judge whether the dataset as a whole was ok to use,\n\n-   and decide whether I would need to contact the data provider to address any quality issues.\n\nMany tests would be sanity checks, whether a datapoint fell between a lower and upper bound, among others. Others could be more complex. And each field would require its own set of validation tests, sometimes fairly unique to that field.\n\n## Example Data\n\nI'll use `iris` as the example dataset. It's got four decimal fields and one factor field per observation.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 150 × 6\n   id    Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n   <chr>        <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n 1 1              5.1         3.5          1.4         0.2 setosa \n 2 2              4.9         3            1.4         0.2 setosa \n 3 3              4.7         3.2          1.3         0.2 setosa \n 4 4              4.6         3.1          1.5         0.2 setosa \n 5 5              5           3.6          1.4         0.2 setosa \n 6 6              5.4         3.9          1.7         0.4 setosa \n 7 7              4.6         3.4          1.4         0.3 setosa \n 8 8              5           3.4          1.5         0.2 setosa \n 9 9              4.4         2.9          1.4         0.2 setosa \n10 10             4.9         3.1          1.5         0.1 setosa \n# … with 140 more rows\n# ℹ Use `print(n = ...)` to see more rows\n```\n\n\n:::\n:::\n\n\n## The Field-Test Catalog\n\nAs I thought about the problem, it became clear that I would want to define a set of validation tests for each field and keep track of the field-test catalog in a list or a table structure.\n\nThe catalog of field-tests might look something like this:\n\n| Field Name   | Test Name                                        |\n|--------------|--------------------------------------------------|\n| Sepal.Length | is_missing                                       |\n| Sepal.Length | is_not_between_3_and_7                           |\n| Sepal.Length | is_less_than_sepal_width                         |\n| ...          | ...                                              |\n| Sepal.Width  | is_missing                                       |\n| Sepal.Width  | ...                                              |\n| ...          | ...                                              |\n| Petal.Length | is_missing                                       |\n| Petal.Length | is_not_between_4_and_7_when_species_is_virginica |\n| ...          |                                                  |\n\n## Desired Output Form\n\nI wanted to generate a set of results for each field-test that I could tie back to individual observations in the data. Results for one particular field's test would look like this:\n\n| Id  | Result |\n|-----|--------|\n| 1   | FALSE  |\n| 2   | FALSE  |\n| ... | ...    |\n| 149 | TRUE   |\n| 150 | FALSE  |\n\nThis is of course not very useful without knowing its corresponding field and test, so an expanded, flat set of results might look like this:\n\n| Field        | Test                                             | Id  | Result |\n|------------------|--------------------|------------------|------------------|\n| Sepal.Length | is_missing                                       | 1   | TRUE   |\n| Sepal.Length | is_missing                                       | 2   | FALSE  |\n| Sepal.Length | is_missing                                       | ... | ...    |\n| Sepal.Length | is_missing                                       | 138 | TRUE   |\n| ...          |                                                  |     |        |\n| Petal.Width  | is_not_between_4_and_7_when_species_is_virginica | 32  | NA     |\n| ...          |                                                  |     |        |\n| Petal.Width  | is_not_between_4_and_7_when_species_is_virginica | 138 | FALSE  |\n| ...          |                                                  |     |        |\n| Species      | is_not_within_known_set                          | 1   | TRUE   |\n| ...          | ...                                              |     |        |\n\nThe objects I would need to keep track of included:\n\n1.  the field-test catalog\n\n2.  each field-test's source code, parameters, and description\n\n3.  each field-test's results\n\n4.  and the iris_tbl dataset itself\n\nThis smelled like the nested data workflow, but inverted. Rather than mapping one function to a group of datasets, I would feed one dataset to a group of functions.\n\n# Nesting the Function Code into a Tibble\n\nI made a hierarchical list for the field test functions, and then I converted it into a tibble like so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfield_test_functions_list <- list(\n  \"Sepal.Length\" = list(\n    \"is_missing\" = function(data) {\n      data %>% \n        mutate(result = is.na(Sepal.Length)) %>% \n        select(id, result)\n    }\n  ),\n  \"Sepal.Width\" = list(\n    \"is_missing\" = function(data) {\n      data %>% \n        mutate(result = is.na(Sepal.Width)) %>% \n        select(id, result)\n    }\n  ),\n  \"Petal.Length\" = list(\n    \"is_missing\" = function(data) {\n      data %>% \n        mutate(result = is.na(Petal.Width)) %>% \n        select(id, result)\n    },\n    \"is_not_between_4_and_7_when_species_is_virginica\" = function(data) {\n      data %>% \n        mutate(result = if_else(Species == \"virginica\",  \n                                !between(Petal.Length, 4, 7),\n                                NA)) %>%\n        select(id, result)\n    }\n  ),\n  \"Species\" = list(\n    \"is_not_within_known_set\" = function(data) {\n      data %>% \n        mutate(result = \n                 !(Species %in% c(\"setosa\", \"versicolor\", \"virginica\"))) %>% \n        select(id, result)\n    }\n  )\n)\n```\n:::\n\n\nNow let's convert that to a tibble, in steps.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(field_test_functions_list, enframe, name = \"test\", value = \"fun\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$Sepal.Length\n# A tibble: 1 × 2\n  test       fun   \n  <chr>      <list>\n1 is_missing <fn>  \n\n$Sepal.Width\n# A tibble: 1 × 2\n  test       fun   \n  <chr>      <list>\n1 is_missing <fn>  \n\n$Petal.Length\n# A tibble: 2 × 2\n  test                                             fun   \n  <chr>                                            <list>\n1 is_missing                                       <fn>  \n2 is_not_between_4_and_7_when_species_is_virginica <fn>  \n\n$Species\n# A tibble: 1 × 2\n  test                    fun   \n  <chr>                   <list>\n1 is_not_within_known_set <fn>  \n```\n\n\n:::\n:::\n\n\nNow let's make that into a tibble using `enframe()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(field_test_functions_list, enframe, name = \"test\", value = \"fun\") %>% \n  enframe(name = \"field\", value = \"test_tibble\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  field        test_tibble     \n  <chr>        <list>          \n1 Sepal.Length <tibble [1 × 2]>\n2 Sepal.Width  <tibble [1 × 2]>\n3 Petal.Length <tibble [2 × 2]>\n4 Species      <tibble [1 × 2]>\n```\n\n\n:::\n:::\n\n\nAnd one more step: `unnest()` the test_tibbles:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfield_test_tibble <- \n  lapply(field_test_functions_list, enframe, name = \"test\", value = \"fun\") %>% \n  enframe(name = \"field\", value = \"test_tibble\") %>%  \n  unnest(test_tibble)\n\nfield_test_tibble\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  field        test                                             fun   \n  <chr>        <chr>                                            <list>\n1 Sepal.Length is_missing                                       <fn>  \n2 Sepal.Width  is_missing                                       <fn>  \n3 Petal.Length is_missing                                       <fn>  \n4 Petal.Length is_not_between_4_and_7_when_species_is_virginica <fn>  \n5 Species      is_not_within_known_set                          <fn>  \n```\n\n\n:::\n:::\n\n\nNow we have our Tidy field-tests tibble, and we're ready to iterate using `purrr::map`.\n\n# The Real Trick: How to Invoke purrr::map()\n\nWe are iterating over test functions we've named `fun`, and we want to *execute* each of them. This is the really meta part: we want to `map()` the function `exec()` onto each `fun`.\n\nIn `purrr::map` syntax, we normally would map a function `.f` to data `.x` like this:\n\n`map(.x = data, .f = fun)`\n\nBut instead we need to do this: `map(.x = fun, .f = exec)`\n\nAnd since each `fun` expects the argument `data`, we pass it as a third argument:\n\n`map(.x = fun, .f = exec, data = iris_tbl)`\n\nThis will produce our result tibble for each field test, so we can do that all within `mutate` like so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfield_tests_with_results <- \n  field_test_tibble %>% \n  mutate(results = map(.x = fun, .f = exec, data = iris_tbl))\n\nfield_tests_with_results \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n  field        test                                             fun    results \n  <chr>        <chr>                                            <list> <list>  \n1 Sepal.Length is_missing                                       <fn>   <tibble>\n2 Sepal.Width  is_missing                                       <fn>   <tibble>\n3 Petal.Length is_missing                                       <fn>   <tibble>\n4 Petal.Length is_not_between_4_and_7_when_species_is_virginica <fn>   <tibble>\n5 Species      is_not_within_known_set                          <fn>   <tibble>\n```\n\n\n:::\n:::\n\n\nAs you can see, Each field-test's field name, test name, code, and results are all tied together in a row.\n\nAnd of course, we can then unnest our results into our desired tabular output:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfield_tests_with_results %>% \n  select(field, test, results) %>% \n  unnest(results)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 750 × 4\n   field        test       id    result\n   <chr>        <chr>      <chr> <lgl> \n 1 Sepal.Length is_missing 1     FALSE \n 2 Sepal.Length is_missing 2     FALSE \n 3 Sepal.Length is_missing 3     FALSE \n 4 Sepal.Length is_missing 4     FALSE \n 5 Sepal.Length is_missing 5     FALSE \n 6 Sepal.Length is_missing 6     FALSE \n 7 Sepal.Length is_missing 7     FALSE \n 8 Sepal.Length is_missing 8     FALSE \n 9 Sepal.Length is_missing 9     FALSE \n10 Sepal.Length is_missing 10    FALSE \n# … with 740 more rows\n# ℹ Use `print(n = ...)` to see more rows\n```\n\n\n:::\n:::\n\n\n*Note: since `data` is a constant, it doesn't need to live in our tibble, which would be duplicative and likely make our tibble enormous.*\n\nBut why do it this way? Couldn't I just do this using vectors and lists?\n\n# A Fine but Less Tidy Method Using Lists\n\nOne way I might have done this before knowing about nested tibbles is to iterate over the field test list to create a separate, hierarchical results list.\n\nThis is...fine. But if you're used to working with Tidy tibbles and dplyr-like verbs you might find it unsatisfying.\n\nFurthermore, if you care about future-proofing it for other users (including your future self), it might bother you that the field test code will be in one object and its results in another, since they aren't aware of each other and it's up to the developer to make sure the names stay correct. Mistakes happen!\n\nIn any case, here's how I would do it. Given the `field_test_functions_list` I created above, I would iterate over our fields using `lapply`, and within that, iterate over each of its tests using another `lapply`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# iterate over field names, and test names within them, executing test functions on iris\nfield_test_results <- lapply(X = field_test_functions_list, \n                             # for each field fn, which is a list of tests...\n                             FUN = function(tests) {\n                               # execute each test, each of which are functions\n                               lapply(X = tests, \n                                      FUN = function(test) {\n                                        exec(test, data = iris_tbl)\n                                      })\n                             })\n\nstr(field_test_results) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ Sepal.Length:List of 1\n  ..$ is_missing: tibble [150 × 2] (S3: tbl_df/tbl/data.frame)\n  .. ..$ id    : chr [1:150] \"1\" \"2\" \"3\" \"4\" ...\n  .. ..$ result: logi [1:150] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ Sepal.Width :List of 1\n  ..$ is_missing: tibble [150 × 2] (S3: tbl_df/tbl/data.frame)\n  .. ..$ id    : chr [1:150] \"1\" \"2\" \"3\" \"4\" ...\n  .. ..$ result: logi [1:150] FALSE FALSE FALSE FALSE FALSE FALSE ...\n $ Petal.Length:List of 2\n  ..$ is_missing                                      : tibble [150 × 2] (S3: tbl_df/tbl/data.frame)\n  .. ..$ id    : chr [1:150] \"1\" \"2\" \"3\" \"4\" ...\n  .. ..$ result: logi [1:150] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  ..$ is_not_between_4_and_7_when_species_is_virginica: tibble [150 × 2] (S3: tbl_df/tbl/data.frame)\n  .. ..$ id    : chr [1:150] \"1\" \"2\" \"3\" \"4\" ...\n  .. ..$ result: logi [1:150] NA NA NA NA NA NA ...\n $ Species     :List of 1\n  ..$ is_not_within_known_set: tibble [150 × 2] (S3: tbl_df/tbl/data.frame)\n  .. ..$ id    : chr [1:150] \"1\" \"2\" \"3\" \"4\" ...\n  .. ..$ result: logi [1:150] FALSE FALSE FALSE FALSE FALSE FALSE ...\n```\n\n\n:::\n:::\n\n\nNow if we want to examine a given field test and its results, we would need to select it with a field name and a test name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfields <- names(field_test_functions_list)\n\ntests <- names(field_test_functions_list[[fields[2]]])\n\nfield_test_functions_list[[fields[2]]][[tests[1]]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction(data) {\n      data %>% \n        mutate(result = is.na(Sepal.Width)) %>% \n        select(id, result)\n    }\n<bytecode: 0x7fea98f27ea8>\n```\n\n\n:::\n\n```{.r .cell-code}\nfield_test_results[[fields[2]]][[tests[1]]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 150 × 2\n   id    result\n   <chr> <lgl> \n 1 1     FALSE \n 2 2     FALSE \n 3 3     FALSE \n 4 4     FALSE \n 5 5     FALSE \n 6 6     FALSE \n 7 7     FALSE \n 8 8     FALSE \n 9 9     FALSE \n10 10    FALSE \n# … with 140 more rows\n# ℹ Use `print(n = ...)` to see more rows\n```\n\n\n:::\n:::\n\n\nAgain, this is fine, but it feels more precarious as a developer. Perhaps you might alleviate some of that fragility by storing the results and the functions in the same list. That would probably be an improvement. But still, a hierarchical list still doesn't lend itself to using tidyverse verbs, which is partially why I prefer my solution.\n\n# Closing Thoughts \n\nIf you're familiar with the paradigm of iterating over nested data, hopefully this gets you thinking about extending that pattern. After all, you can nest anything into a cell.\n\nFor my data validation problem, I could have used a set of lists and `lapply`, but I find it more fragile and prefer playing well with the tidyverse, which likes tabular data. So I targeted building a single, Tidy tibble with columns for field, test name, each datapoint's id, and test result. The twist was to nest source code into a cell and using `purrr::map` to execute each test.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}